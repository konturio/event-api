<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN" "http://mybatis.org/dtd/mybatis-3-mapper.dtd">
<mapper namespace="io.kontur.eventapi.dao.mapper.ApiMapper">

    <select id="getFeeds" resultMap="feedDtoMap">
        SELECT alias, name, description
        from feeds
    </select>

    <select id="findDataByObservationId" resultType="java.lang.String">
        SELECT data
        from data_lake
        where observation_id = #{observationId}
    </select>

    <select id="searchForEvents" resultType="java.lang.String">
        with events as (
            SELECT
                fd.event_id, fd.version, fd.name, fd.proper_name, fd.description, fd.type, sv.severity, fd.active,
                fd.started_at, fd.ended_at, fd.updated_at, fd.location, fd.urls, fd.loss, fd.severity_data, fd.event_details, fd.observations, fd.geometries,
                jsonb_array_length(fd.episodes) as episode_count,
                <choose>
                    <when test='"LATEST".equalsIgnoreCase(episodeFilterType)'>
                        jsonb_build_array((SELECT episode from jsonb_array_elements(fd.episodes) episode
                                           order by (episode ->> 'updatedAt')::timestamptz desc
                                           limit 1)) as episodes,
                    </when>
                    <when test='"NONE".equalsIgnoreCase(episodeFilterType)'>
                        '[]'::jsonb as episodes,
                    </when>
                    <otherwise>fd.episodes,</otherwise>
                </choose>
                box2d(fd.collected_geometry) as bbox, st_pointonsurface(fd.collected_geometry) as centroid
            from feed_data fd
            left join severities sv on fd.severity_id = sv.severity_id
            where fd.feed_id = ( SELECT feed_id from feeds where alias = #{feedAlias} )
                and fd.is_latest_version and fd.enriched
                <if test="eventTypes!=null &amp;&amp; !eventTypes.isEmpty" >
                    <foreach item="eventType" collection="eventTypes" separator="," open="and fd.type in (" close=")">
                        #{eventType}::text
                    </foreach>
                </if>
                <if test="severities!=null &amp;&amp; !severities.isEmpty"  >
                    <foreach item="severity" collection="severities" separator="," open="and fd.severity_id &gt;= (SELECT min(severity_id) from severities where severity in (" close="))">
                        #{severity}::text
                    </foreach>
                    <foreach item="severity" collection="severities" separator="," open="and fd.severity_id &lt;= (SELECT max(severity_id) from severities where severity in (" close="))">
                        #{severity}::text
                    </foreach>
                </if>
                <if test='from != null'><![CDATA[and (fd.ended_at >= #{from})]]></if>
                <if test='to != null'><![CDATA[and (fd.started_at <= #{to})]]></if>
                <if test='updatedAfter != null'>
                    <if test='"ASC".equalsIgnoreCase(sortOrder)'>and fd.updated_at > #{updatedAfter}</if>
                    <if test='"DESC".equalsIgnoreCase(sortOrder)'>and fd.updated_at &lt; #{updatedAfter}</if>
                </if>
                <if test="xMin!=null &amp;&amp; yMin!=null &amp;&amp; xMax!=null &amp;&amp; yMax!=null">
                    and ST_Intersects(ST_MakeEnvelope(#{xMin}, #{yMin}, #{xMax}, #{yMax}, 4326), fd.collected_geometry)
                </if>
            order by fd.updated_at ${sortOrder}
            limit #{limit}
        )
        SELECT case when count(*) > 0 then json_build_object(
            'pageMetadata', json_build_object('nextAfterValue',
                (SELECT
                    <choose>
                        <when test='"DESC".equalsIgnoreCase(sortOrder)'>min(e.updated_at)</when>
                        <otherwise>max(e.updated_at)</otherwise>
                    </choose>
                from events e)),
            'data', json_agg(json_build_object(
                'eventId', event_id,
                'version', version,
                'name', name,
                'properName', proper_name,
                'description', description,
                'type', type,
                'severity', severity,
                'active', active,
                'startedAt', started_at,
                'endedAt', ended_at,
                'updatedAt', updated_at,
                'location', location,
                'urls', urls,
                'loss', loss,
                'severityData', severity_data,
                'eventDetails', event_details,
                'observations', observations,
                'geometries', geometries,
                'episodes', episodes,
                'episodeCount', episode_count,
                'bbox', array[st_xmin(bbox), st_ymin(bbox), st_xmax(bbox),st_ymax(bbox)],
                'centroid', array[st_x(centroid), st_y(centroid)]
              )))
            end
        from events
    </select>

    <select id="getEventByEventIdAndByVersionOrLast" resultType="java.lang.String">
        with event as (
            SELECT
                fd.event_id, fd.feed_id, fd.version, fd.name, fd.proper_name, fd.description, fd.type, sv.severity, fd.active,
                fd.started_at, fd.ended_at, fd.updated_at, fd.location, fd.urls, fd.loss, fd.severity_data, fd.event_details, fd.observations, fd.geometries,
                jsonb_array_length(fd.episodes) as episode_count,
                <choose>
                    <when test='"LATEST".equalsIgnoreCase(episodeFilterType)'>
                        jsonb_build_array((
                        SELECT episode from jsonb_array_elements(fd.episodes) episode
                        order by (episode ->> 'updatedAt')::timestamptz desc
                        limit 1
                        )) as episodes,
                    </when>
                    <when test='"NONE".equalsIgnoreCase(episodeFilterType)'>
                        '[]'::jsonb as episodes,
                    </when>
                    <otherwise>fd.episodes,</otherwise>
                </choose>
                box2d(fd.collected_geometry) as bbox, st_pointonsurface(fd.collected_geometry) as centroid
            from feed_data fd
            left join severities sv on fd.severity_id = sv.severity_id
            where fd.event_id = #{eventId}
                and fd.feed_id = ( SELECT feed_id from feeds where alias = #{feedAlias} )
                <choose>
                    <when test="version != null">and fd.version = #{version}</when>
                    <otherwise>and fd.is_latest_version</otherwise>
                </choose>
        )
        SELECT
            json_build_object(
                'eventId', event_id,
                'version', version,
                'name', name,
                'properName', proper_name,
                'description', description,
                'type', type,
                'severity', severity,
                'active', active,
                'startedAt', started_at,
                'endedAt', ended_at,
                'updatedAt', updated_at,
                'location', location,
                'urls', urls,
                'loss', loss,
                'severityData', severity_data,
                'eventDetails', event_details,
                'observations', observations,
                'geometries', geometries,
                'episodes', episodes,
                'episodeCount', episode_count,
                'bbox', array[st_xmin(bbox), st_ymin(bbox), st_xmax(bbox),st_ymax(bbox)],
                'centroid', array[st_x(centroid), st_y(centroid)]
              )
        from event
    </select>

    <select id="searchForEventsGeoJson" resultType="java.lang.String">
        with events as (
            SELECT
                fd.event_id, fd.updated_at,
                <choose>
                    <when test='"LATEST".equalsIgnoreCase(episodeFilterType)'>
                        jsonb_build_array((SELECT episode from jsonb_array_elements(fd.episodes) episode
                                           order by (episode ->> 'updatedAt')::timestamptz desc
                                           limit 1)) as episodes
                    </when>
                    <when test='"NONE".equalsIgnoreCase(episodeFilterType)'>
                        '[]'::jsonb as episodes
                    </when>
                    <otherwise>fd.episodes</otherwise>
                </choose>
            from feed_data fd
            left join severities sv on fd.severity_id = sv.severity_id
            where fd.feed_id = ( SELECT feed_id from feeds where alias = #{feedAlias} )
                and fd.is_latest_version and fd.enriched
                <if test="eventTypes!=null &amp;&amp; !eventTypes.isEmpty" >
                    <foreach item="eventType" collection="eventTypes" separator="," open="and fd.type in (" close=")">
                        #{eventType}::text
                    </foreach>
                </if>
                <if test="severities!=null &amp;&amp; !severities.isEmpty"  >
                    <foreach item="severity" collection="severities" separator="," open="and fd.severity_id &gt;= (SELECT min(severity_id) from severities where severity in (" close="))">
                        #{severity}::text
                    </foreach>
                    <foreach item="severity" collection="severities" separator="," open="and fd.severity_id &lt;= (SELECT max(severity_id) from severities where severity in (" close="))">
                        #{severity}::text
                    </foreach>
                </if>
                <if test='from != null'><![CDATA[and (fd.ended_at >= #{from})]]></if>
                <if test='to != null'><![CDATA[and (fd.started_at <= #{to})]]></if>
                <if test='updatedAfter != null'>
                    <if test='"ASC".equalsIgnoreCase(sortOrder)'>and fd.updated_at > #{updatedAfter}</if>
                    <if test='"DESC".equalsIgnoreCase(sortOrder)'>and fd.updated_at &lt; #{updatedAfter}</if>
                </if>
                <if test="xMin!=null &amp;&amp; yMin!=null &amp;&amp; xMax!=null &amp;&amp; yMax!=null">
                    and ST_MakeEnvelope(#{xMin}, #{yMin}, #{xMax}, #{yMax}, 4326) &amp;&amp; fd.collected_geometry
                </if>
            order by fd.updated_at ${sortOrder}
            limit #{limit}
        ),
        episodes as (
            SELECT event_id, jsonb_array_elements(episodes) episode
            from events
        ),
        features as (
            SELECT event_id, episode, jsonb_array_elements(episode -> 'geometries' -> 'features') feature
            from episodes
        ),
        props as (
            SELECT
                event_id as "eventId",
                episode -> 'name' as episode_name,
                episode -> 'properName' as "episode_properName",
                episode -> 'description' as episode_description,
                episode -> 'type' as episode_type,
                episode -> 'severity' as episode_severity,
                episode -> 'startedAt' as "episode_startedAt",
                episode -> 'endedAt' as "episode_endedAt",
                episode -> 'updatedAt' as "episode_updatedAt",
                episode -> 'sourceUpdatedAt' as "episode_sourceUpdatedAt",
                episode -> 'location' as episode_location,
                episode -> 'urls' as episode_urls,
                episode -> 'loss' as episode_loss,
                episode -> 'severityData' as "episode_severityData",
                episode -> 'episodeDetails' as "episode_episodeDetails",
                episode -> 'observations' as episode_observations,
                feature -> 'properties' -> 'isObserved' as "feature_isObserved",
                feature -> 'properties' -> 'forecastHrs' as "feature_forecastHrs",
                feature -> 'properties' -> 'timestamp' as feature_timestamp,
                feature -> 'properties' -> 'areaType' as "feature_areaType",
                feature -> 'properties' -> 'severityData' as "feature_severityData",
                ST_GeomFromGeoJSON(feature -> 'geometry') as geom
            from features
        )
        SELECT
            case when count(*) > 0 then json_build_object(
                'type', 'FeatureCollection',
                'pageMetadata', json_build_object('nextAfterValue',
                    (SELECT
                        <choose>
                            <when test='"DESC".equalsIgnoreCase(sortOrder)'>min(e.updated_at)</when>
                            <otherwise>max(e.updated_at)</otherwise>
                        </choose>
                    from events e)),
                'features', json_agg(ST_AsGeoJSON(props.*)::json))
            end
        from props
    </select>

    <resultMap id="feedDtoMap" type="io.kontur.eventapi.resource.dto.FeedDto">
        <result property="feed" column="alias"/>
        <result property="name" column="name"/>
        <result property="description" column="description"/>
    </resultMap>

</mapper>