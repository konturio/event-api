<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN" "http://mybatis.org/dtd/mybatis-3-mapper.dtd">
<mapper namespace="io.kontur.eventapi.dao.mapper.ApiMapper">

    <select id="getFeeds" resultMap="feedDtoMap">
        select alias, name, description
        from feeds
    </select>

    <select id="findSimilarEvents" resultType="java.lang.String">
        with target as (
            select fd.collected_geometry, fd.type
            from feed_data fd
            where fd.event_id = #{eventId}
              and fd.feed_id = (select feed_id from feeds where alias = #{feedAlias})
              and fd.is_latest_version
        ), events as (
            select
                fd.event_id, fd.version, fd.name, fd.proper_name, fd.description, fd.type,
                sv.severity, fd.active,
                fd.started_at, fd.ended_at, fd.updated_at, fd.location, fd.urls,
                fd.loss, fd.severity_data, fd.event_details, fd.observations, fd.geometries,
                jsonb_array_length(fd.episodes) as episode_count,
                fd.episodes,
                box2d(fd.collected_geometry) as bbox,
                st_pointonsurface(fd.collected_geometry) as centroid,
                st_distance(fd.collected_geometry::geography, t.collected_geometry::geography) as dist
            from feed_data fd
            cross join target t
            left join severities sv on fd.severity_id = sv.severity_id
            where fd.feed_id = (select feed_id from feeds where alias = #{feedAlias})
              and fd.is_latest_version and fd.enriched
              and fd.event_id != #{eventId}
              and fd.type = t.type
              and st_dwithin(fd.collected_geometry::geography, t.collected_geometry::geography, #{distance})
            order by dist
            limit #{limit}
        )
        select case when count(*) > 0 then json_build_object(
                'data', json_agg(json_build_object(
                        'eventId', event_id,
                        'version', version,
                        'name', name,
                        'properName', proper_name,
                        'description', description,
                        'type', type,
                        'severity', severity,
                        'active', active,
                        'startedAt', started_at,
                        'endedAt', ended_at,
                        'updatedAt', updated_at,
                        'location', location,
                        'urls', urls,
                        'loss', loss,
                        'severityData', severity_data,
                        'eventDetails', event_details,
                        'observations', observations,
                        'geometries', geometries,
                        'episodes', episodes,
                        'episodeCount', episode_count,
                        'bbox', array[st_xmin(bbox), st_ymin(bbox), st_xmax(bbox), st_ymax(bbox)],
                        'centroid', array[st_x(centroid), st_y(centroid)]
                )))
            end
        from events;
    </select>

    <select id="findDataByObservationId" resultType="java.lang.String">
        select data
        from data_lake
        where observation_id = #{observationId}
    </select>

    <select id="searchForEvents" resultType="java.lang.String">
        with events as (
            select
                fd.event_id, fd.version, fd.name, fd.proper_name, fd.description, fd.type, sv.severity, fd.active,
                fd.started_at, fd.ended_at, fd.updated_at, fd.location, fd.urls, fd.loss, fd.severity_data, fd.event_details, fd.observations, fd.geometries,
                jsonb_array_length(fd.episodes) as episode_count,
                <choose>
                    <when test='"LATEST".equalsIgnoreCase(episodeFilterType)'>
                        jsonb_build_array((select episode from jsonb_array_elements(fd.episodes) episode
                                           order by (episode ->> 'updatedAt')::timestamptz desc
                                           limit 1)) as episodes,
                    </when>
                    <when test='"NONE".equalsIgnoreCase(episodeFilterType)'>
                        '[]'::jsonb as episodes,
                    </when>
                    <otherwise>fd.episodes,</otherwise>
                </choose>
                box2d(fd.collected_geometry) as bbox, st_pointonsurface(fd.collected_geometry) as centroid
            from feed_data fd
            left join severities sv on fd.severity_id = sv.severity_id
            where fd.feed_id = ( select feed_id from feeds where alias = #{feedAlias} )
                and fd.is_latest_version and fd.enriched
                <if test="eventTypes!=null &amp;&amp; !eventTypes.isEmpty" >
                    <foreach item="eventType" collection="eventTypes" separator="," open="and fd.type in (" close=")">
                        #{eventType}::text
                    </foreach>
                </if>
                <if test="severities!=null &amp;&amp; !severities.isEmpty"  >
                    <foreach item="severity" collection="severities" separator="," open="and fd.severity_id &gt;= (select min(severity_id) from severities where severity in (" close="))">
                        #{severity}::text
                    </foreach>
                    <foreach item="severity" collection="severities" separator="," open="and fd.severity_id &lt;= (select max(severity_id) from severities where severity in (" close="))">
                        #{severity}::text
                    </foreach>
                </if>
                <if test='from != null'><![CDATA[and (fd.ended_at >= #{from})]]></if>
                <if test='to != null'><![CDATA[and (fd.started_at <= #{to})]]></if>
                <if test='updatedAfter != null'>
                    <if test='"asc".equalsIgnoreCase(sortOrder)'>and fd.updated_at > #{updatedAfter}</if>
                    <if test='"desc".equalsIgnoreCase(sortOrder)'>and fd.updated_at &lt; #{updatedAfter}</if>
                </if>
                <if test="xMin!=null &amp;&amp; yMin!=null &amp;&amp; xMax!=null &amp;&amp; yMax!=null">
                    and ST_Intersects(ST_MakeEnvelope(#{xMin}, #{yMin}, #{xMax}, #{yMax}, 4326), fd.collected_geometry)
                </if>
            order by fd.updated_at ${sortOrder}
            limit #{limit}
        )
        select case when count(*) > 0 then json_build_object(
            'pageMetadata', json_build_object('nextAfterValue',
                (select
                    <choose>
                        <when test='"desc".equalsIgnoreCase(sortOrder)'>min(e.updated_at)</when>
                        <otherwise>max(e.updated_at)</otherwise>
                    </choose>
                from events e)),
            'data', json_agg(json_build_object(
                'eventId', event_id,
                'version', version,
                'name', name,
                'properName', proper_name,
                'description', description,
                'type', type,
                'severity', severity,
                'active', active,
                'startedAt', started_at,
                'endedAt', ended_at,
                'updatedAt', updated_at,
                'location', location,
                'urls', urls,
                'loss', loss,
                'severityData', severity_data,
                'eventDetails', event_details,
                'observations', observations,
                'geometries', geometries,
                'episodes', episodes,
                'episodeCount', episode_count,
                'bbox', array[st_xmin(bbox), st_ymin(bbox), st_xmax(bbox),st_ymax(bbox)],
                'centroid', array[st_x(centroid), st_y(centroid)]
              )))
            end
        from events
    </select>

    <select id="getEventByEventIdAndByVersionOrLast" resultType="java.lang.String">
        with event as (
            select
                fd.event_id, fd.feed_id, fd.version, fd.name, fd.proper_name, fd.description, fd.type, sv.severity, fd.active,
                fd.started_at, fd.ended_at, fd.updated_at, fd.location, fd.urls, fd.loss, fd.severity_data, fd.event_details, fd.observations, fd.geometries,
                jsonb_array_length(fd.episodes) as episode_count,
                <choose>
                    <when test='"LATEST".equalsIgnoreCase(episodeFilterType)'>
                        jsonb_build_array((
                        select episode from jsonb_array_elements(fd.episodes) episode
                        order by (episode ->> 'updatedAt')::timestamptz desc
                        limit 1
                        )) as episodes,
                    </when>
                    <when test='"NONE".equalsIgnoreCase(episodeFilterType)'>
                        '[]'::jsonb as episodes,
                    </when>
                    <otherwise>fd.episodes,</otherwise>
                </choose>
                box2d(fd.collected_geometry) as bbox, st_pointonsurface(fd.collected_geometry) as centroid
            from feed_data fd
            left join severities sv on fd.severity_id = sv.severity_id
            where fd.event_id = #{eventId}
                and fd.feed_id = ( select feed_id from feeds where alias = #{feedAlias} )
                <choose>
                    <when test="version != null">and fd.version = #{version}</when>
                    <otherwise>and fd.is_latest_version</otherwise>
                </choose>
        )
        select
            json_build_object(
                'eventId', event_id,
                'version', version,
                'name', name,
                'properName', proper_name,
                'description', description,
                'type', type,
                'severity', severity,
                'active', active,
                'startedAt', started_at,
                'endedAt', ended_at,
                'updatedAt', updated_at,
                'location', location,
                'urls', urls,
                'loss', loss,
                'severityData', severity_data,
                'eventDetails', event_details,
                'observations', observations,
                'geometries', geometries,
                'episodes', episodes,
                'episodeCount', episode_count,
                'bbox', array[st_xmin(bbox), st_ymin(bbox), st_xmax(bbox),st_ymax(bbox)],
                'centroid', array[st_x(centroid), st_y(centroid)]
              )
        from event
    </select>

    <select id="searchForEventsGeoJson" resultType="java.lang.String">
        with events as (
            select
                fd.event_id, fd.updated_at,
                <choose>
                    <when test='"LATEST".equalsIgnoreCase(episodeFilterType)'>
                        jsonb_build_array((select episode from jsonb_array_elements(fd.episodes) episode
                                           order by (episode ->> 'updatedAt')::timestamptz desc
                                           limit 1)) as episodes
                    </when>
                    <when test='"NONE".equalsIgnoreCase(episodeFilterType)'>
                        '[]'::jsonb as episodes
                    </when>
                    <otherwise>fd.episodes</otherwise>
                </choose>
            from feed_data fd
            left join severities sv on fd.severity_id = sv.severity_id
            where fd.feed_id = ( select feed_id from feeds where alias = #{feedAlias} )
                and fd.is_latest_version and fd.enriched
                <if test="eventTypes!=null &amp;&amp; !eventTypes.isEmpty" >
                    <foreach item="eventType" collection="eventTypes" separator="," open="and fd.type in (" close=")">
                        #{eventType}::text
                    </foreach>
                </if>
                <if test="severities!=null &amp;&amp; !severities.isEmpty"  >
                    <foreach item="severity" collection="severities" separator="," open="and fd.severity_id &gt;= (select min(severity_id) from severities where severity in (" close="))">
                        #{severity}::text
                    </foreach>
                    <foreach item="severity" collection="severities" separator="," open="and fd.severity_id &lt;= (select max(severity_id) from severities where severity in (" close="))">
                        #{severity}::text
                    </foreach>
                </if>
                <if test='from != null'><![CDATA[and (fd.ended_at >= #{from})]]></if>
                <if test='to != null'><![CDATA[and (fd.started_at <= #{to})]]></if>
                <if test='updatedAfter != null'>
                    <if test='"asc".equalsIgnoreCase(sortOrder)'>and fd.updated_at > #{updatedAfter}</if>
                    <if test='"desc".equalsIgnoreCase(sortOrder)'>and fd.updated_at &lt; #{updatedAfter}</if>
                </if>
                <if test="xMin!=null &amp;&amp; yMin!=null &amp;&amp; xMax!=null &amp;&amp; yMax!=null">
                    and ST_MakeEnvelope(#{xMin}, #{yMin}, #{xMax}, #{yMax}, 4326) &amp;&amp; fd.collected_geometry
                </if>
            order by fd.updated_at ${sortOrder}
            limit #{limit}
        ),
        episodes as (
            select event_id, jsonb_array_elements(episodes) episode
            from events
        ),
        features as (
            select event_id, episode, jsonb_array_elements(episode -> 'geometries' -> 'features') feature
            from episodes
        ),
        props as (
            select
                event_id as "eventId",
                episode -> 'name' as episode_name,
                episode -> 'properName' as "episode_properName",
                episode -> 'description' as episode_description,
                episode -> 'type' as episode_type,
                episode -> 'severity' as episode_severity,
                episode -> 'startedAt' as "episode_startedAt",
                episode -> 'endedAt' as "episode_endedAt",
                episode -> 'updatedAt' as "episode_updatedAt",
                episode -> 'sourceUpdatedAt' as "episode_sourceUpdatedAt",
                episode -> 'location' as episode_location,
                episode -> 'urls' as episode_urls,
                episode -> 'loss' as episode_loss,
                episode -> 'severityData' as "episode_severityData",
                episode -> 'episodeDetails' as "episode_episodeDetails",
                episode -> 'observations' as episode_observations,
                feature -> 'properties' -> 'isObserved' as "feature_isObserved",
                feature -> 'properties' -> 'forecastHrs' as "feature_forecastHrs",
                feature -> 'properties' -> 'timestamp' as feature_timestamp,
                feature -> 'properties' -> 'areaType' as "feature_areaType",
                feature -> 'properties' -> 'severityData' as "feature_severityData",
                ST_GeomFromGeoJSON(feature -> 'geometry') as geom
            from features
        )
        select
            case when count(*) > 0 then json_build_object(
                'type', 'FeatureCollection',
                'pageMetadata', json_build_object('nextAfterValue',
                    (select
                        <choose>
                            <when test='"desc".equalsIgnoreCase(sortOrder)'>min(e.updated_at)</when>
                            <otherwise>max(e.updated_at)</otherwise>
                        </choose>
                    from events e)),
                'features', json_agg(ST_AsGeoJSON(props.*)::json))
            end
        from props
    </select>

    <resultMap id="feedDtoMap" type="io.kontur.eventapi.resource.dto.FeedDto">
        <result property="feed" column="alias"/>
        <result property="name" column="name"/>
        <result property="description" column="description"/>
    </resultMap>

</mapper>