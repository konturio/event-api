<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE mapper
        PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN"
        "http://mybatis.org/dtd/mybatis-3-mapper.dtd">
<mapper namespace="io.kontur.eventapi.dao.mapper.KonturEventsMapper">

    <insert id="insert" useGeneratedKeys="false">
        insert into kontur_events (event_id, provider, observation_id)
        values (#{eventId}, #{provider}, #{observationId})
        on conflict (event_id, observation_id) do update
        set provider = #{provider}
    </insert>

    <select id="getEventByExternalId" resultMap="konturEventDtoMap" >
        select event_id, array_agg(observation_id)::uuid[] as observation_ids, min(recombined_at) as recombined_at
        from kontur_events
        where observation_id in (
            select observation_id
            from normalized_observations
            where external_event_id = #{externalId}
            )
        group by event_id
    </select>

    <select id="getEventById" resultMap="konturEventDtoMap" >
        select event_id, array_agg(observation_id)::uuid[] as observation_ids, min(recombined_at) as recombined_at
        from kontur_events
        where event_id = #{eventId}
        group by event_id
    </select>

    <select id="findClosestEventsToObservations" resultMap="konturEventDtoMap">
        with observations as (
            select observation_id, source_updated_at, collected_geography
            from normalized_observations
            where observation_id in
            <foreach item="id" collection="observationIds" separator="," open="(" close=")">
                #{id}
            </foreach>
        ),
        events as (
            select ((
                select ke.event_id
                from kontur_events ke inner join normalized_observations no on ke.observation_id = no.observation_id
                where ke.provider in ('firms.modis-c6', 'firms.suomi-npp-viirs-c2', 'firms.noaa-20-viirs-c2')
                    <if test='eventIds != null'>
                        <foreach item="eventId" collection="eventIds" open="and ke.event_id in (" separator="," close=")">
                            #{eventId}
                        </foreach>
                    </if>
                    and no.source_updated_at between obs.source_updated_at - interval '24 hours'
                        and obs.source_updated_at + interval '24 hours'
                    and ST_DWithin(obs.collected_geography, no.collected_geography, 2000)
                order by st_distance(obs.collected_geography, no.collected_geography)
                limit 1)) as event_id, array_agg(obs.observation_id)::uuid[] as observation_ids
            from observations obs
            group by event_id
        )
        select * from events where event_id is not null
    </select>

    <select id="getEventsForRolloutEpisodes" resultType="java.util.UUID">
        select event_id
        from feed_event_status
        where feed_id = #{feedId}
            and actual is false
        limit 100000;
    </select>

    <select id="getNotComposedEventsCount" resultType="java.lang.Integer">
        select count(*) from feed_event_status where not actual;
    </select>

    <select id="getNotComposedEventsCountForFeeds" resultType="java.lang.Integer">
        select count(*) from feed_event_status fes
        join feeds f on f.feed_id = fes.feed_id
        where not actual
          and f.alias in
        <foreach item="alias" collection="aliases" open="(" separator="," close=")">
            #{alias}
        </foreach>
    </select>

    <resultMap id="konturEventDtoMap" type="io.kontur.eventapi.entity.KonturEvent">
        <result property="eventId" column="event_id"/>
        <result property="observationIds" column="observation_ids" typeHandler="io.kontur.eventapi.typehandler.UUIDArrayTypeHandler"/>
        <result property="recombinedAt" column="recombined_at"/>
    </resultMap>
</mapper>